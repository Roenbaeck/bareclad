traqula = _{
    SOI ~
    (add_role | add_posit | search)* ~
    EOI
}

// common tokens
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
digit = _{ '0'..'9' }
int = { "-"? ~ digit+ }
decimal = { "-"? ~ digit+ ~ "." ~ digit+ }
certainty = { "-"? ~ digit{1,3} ~ "%" }
time = { "'" ~ (digit | "-" | ":")+ ~ "'" }
json = @{ "{" ~ (json | !"}" ~ ANY)* ~ "}" }
string = { "\"" ~ ( "\"\"" | (!"\"" ~ ANY) )* ~ "\"" }
// Reserved keywords (cannot be used as bare variable names)
keyword = { "add" | "role" | "posit" | "search" | "return" | "where" | "as" | "of" | "limit" | "and" }
// A variable is an identifier not exactly equal to a reserved keyword.
// Negative lookahead excludes exact keyword tokens but allows identifiers like 'limitX'.
variable = ${ !(keyword ~ ! (CASED_LETTER | digit | "_" )) ~ CASED_LETTER ~ (CASED_LETTER | digit | "_" )* }
constant = { "@" ~ UPPERCASE_LETTER+ }

// add role command
role = { (CASED_LETTER | SPACE_SEPARATOR)+ }
add_role = { ^"add role" ~ (role ~ ","?)+ ~ ";" }

// add posit command
insert = { "+" ~ variable }
recall = { variable }
appearance = { "(" ~ (insert | recall) ~ "," ~ role ~ ")" } 
appearance_set = { "{" ~ (appearance ~ ","?)+ ~ "}" }
appearing_value = { constant | json | string | time | certainty | decimal | int }
appearance_time = { constant | time }
posit = { 
    insert? ~ 
    "[" ~ appearance_set ~ "," ~ appearing_value ~ "," ~ appearance_time ~ "]" 
}
add_posit = { ^"add posit" ~ (posit ~ ","?)+ ~ ";" } 

// search command
wildcard = { "*" }
recall_union = { recall ~ ("|" ~ recall)+ }
appearance_search = { "(" ~ (wildcard | insert | recall_union | recall) ~ "," ~ (wildcard | role) ~ ")" } 
appearance_set_search = { (wildcard | "{" ~ (appearance_search ~ ","?)+ ~ "}") }
appearing_value_search = { (wildcard | insert | recall | constant | json | string | time | certainty | decimal | int) }
appearance_time_search = { (wildcard | insert | recall | constant | time) }
posit_search = { 
    insert? ~ 
    "[" ~ appearance_set_search ~ "," ~ appearing_value_search ~ "," ~ appearance_time_search ~ "]" ~ as_of_clause?
}
return_clause = { ^"return" ~ (recall ~ ","?)+ }
search_clause = { ^"search" ~ (posit_search ~ ","?)+ }
// where clause: variable comparator value/variable. Initially engine only enforced time, but grammar now allows broader RHS.
comparator = { "<=" | ">=" | "<" | ">" | "==" | "=" }
rhs_value = { constant | time | certainty | decimal | int | string }
condition = { recall ~ comparator ~ (rhs_value | recall) }
where_clause = { ^"where" ~ condition ~ ("and" ~ condition)* }
limit_clause = { ^"limit" ~ int }
search = { search_clause ~ where_clause? ~ return_clause ~ limit_clause? ~ ";" }

// Optional per-pattern 'as of' clause
as_of_clause = { "as of" ~ (constant | time | recall) }
