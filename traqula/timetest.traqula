add role  wife, husband, name;

add posit [{(+idw, wife), (+idh, husband)}, "married", '2004-06-19'], /* first married */
          [{(idw, wife), (idh, husband)}, "divorced", '2020-12-04'], /* then divorced */
          [{(idw, wife), (idh, husband)}, "married", '2024-03-17'], /* then remarried */
          [{(idh, name)}, "Archie Bald", '1972-08-20'], /* husband's given name at birth */
          [{(idh, name)}, "Archie Trix", '2004-09-21'], /* took wife's surname after marriage */
          [{(idh, name)}, "Archie Bald", '2021-01-19'], /* reverted to birth name after divorce */
          [{(idw, name)}, "Bella Trix", '1972-12-13'], /* wife's given name at birth */
          [{(idw, name)}, "Bella Bald", '2024-05-29']; /* took husband's surname after remarrying him */

/* sanity check, give me all names stored for divorced couples (at any point in time) */
search    [{(+w, wife), (+h, husband)}, "divorced", *], 
          [{(w|h, name)}, +n, +t]
return
    n, t;

/* give me all names stored for couples that are currently divorced */
search    [{(+w, wife), (+h, husband)}, "divorced", +mt] as of @NOW, 
          [{(w|h, name)}, +n, +t]
return
    n, t, mt;

/* give me all names stored for couples that are currently married */
search    [{(+w, wife), (+h, husband)}, "married", +mt] as of @NOW, 
          [{(w|h, name)}, +n, +t]
return
    n, t, mt;


/*
The intent of "as of" is always to be a snapshot reducer.  In the case of `[{(w, name)}, +n, +t] as of t1` it should reduce for each w's specific t1. It would result in every wives name closest preceding to or on the time of their mariiage.

This is different from 
```
[{(w, name)}, +n, +t] 
where t < t1
````
which is what I believe we have now, and should keep for this particular type of join. Get all names for each wife previous to their marriages. If a wife had two names before, we should get two names.

Another possibility is `[{(w, name)}, +n, t1]` but this matches only those wives who got their name exactly on the day of the marriate. 
*/