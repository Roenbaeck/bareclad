<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Bareclad Query Console</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="bareclad.css" />
</head>
<body>
<!-- Prism.js for syntax highlighting (works with file:// protocol) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<header>
  <img class="svg" src="Traqula.svg"/>
  Bareclad Query Console
</header>
<main>
  <div id="splitContainer">
    <div id="editorPane">
      <section>
        <label for="endpoint">Endpoint</label>
        <input id="endpoint" type="text" value="http://127.0.0.1:8080/v1/query" />
        <label for="script">Traqula Script (Ctrl+Enter to run)</label>
        <div id="script-container">
          <textarea id="script" spellcheck="false"></textarea>
          <pre id="script-highlight"><code class="language-traqula">
search +posit [{(+person, name)}, +name, +since]
return
    posit, person, name, since;
          </code></pre>
        </div>
        <div class="controls">
          <button id="runBtn">Run</button>
          <button id="clearBtn" title="Clear results">Clear</button>
          <label>Timeout <input type="number" id="timeout" min="0" step="100" placeholder="ms"></label>
          <label><input type="checkbox" id="autoScroll" checked> Auto-scroll to latest</label>
          <label><input type="checkbox" id="streamMode"> Stream results</label>
        </div>
        <div id="statusBar"></div>
        <progress id="progress" max="100" value="0"></progress>
      </section>
    </div>
    <div id="splitter" title="Drag to resize"></div>
    <div id="resultsPane">
      <div id="resultsTabs">
        <button class="tabBtn active" data-tab="table">Table</button>
        <button class="tabBtn" data-tab="json">JSON</button>
        <button class="tabBtn" data-tab="status">Status</button>
        <select id="resultSetSelect" style="display:none;" title="Select result set"></select>
        <div></div>
        <span id="perf"></span>
      </div>
      <div id="tableView">
        <table id="resultsTable">
          <thead></thead>
          <tbody></tbody>
        </table>
      </div>
      <div id="jsonView">
        <pre id="jsonOut"></pre>
      </div>
      <div id="statusView">
        <pre id="statusOut"></pre>
      </div>
    </div>
  </div>
</main>
<footer>
  <span>Bareclad local console (dev)</span>
  <span>Drag splitter to resize editor/results • Tabs to switch view • Status tab shows logs</span>
</footer>
<script>
const els = {
  endpoint: document.getElementById('endpoint'),
  script: document.getElementById('script'),
  runBtn: document.getElementById('runBtn'),
  clearBtn: document.getElementById('clearBtn'),
  tableHead: document.querySelector('#resultsTable thead'),
  tableBody: document.querySelector('#resultsTable tbody'),
  status: document.getElementById('statusBar'),
  jsonOut: document.getElementById('jsonOut'),
  autoScroll: document.getElementById('autoScroll'),
  streamMode: document.getElementById('streamMode'),
  timeout: document.getElementById('timeout'),
  perf: document.getElementById('perf'),
  progress: document.getElementById('progress'),
  splitter: document.getElementById('splitter'),
  editorPane: document.getElementById('editorPane'),
  resultsPane: document.getElementById('resultsPane'),
  tabs: document.querySelectorAll('.tabBtn'),
  tableView: document.getElementById('tableView'),
  jsonView: document.getElementById('jsonView'),
  statusView: document.getElementById('statusView'),
  statusOut: document.getElementById('statusOut'),
  resultSetSelect: document.getElementById('resultSetSelect')
};
// Hover highlight feature removed; stubs and related logic eliminated.

// Event listeners for hover highlighting on dropdown
document.addEventListener('DOMContentLoaded', () => {});
let lastResponse = null;

// Load saved query from localStorage
const savedQuery = localStorage.getItem('bareclad-query');
if (savedQuery) {
  els.script.value = savedQuery;
}

// Define Traqula language for Prism.js
Prism.languages.traqula = {
  'comment': /\/\*[\s\S]*?\*\//,
  'keyword': /\b(?:add|role|posit|search|return|where|and|limit|as|of)\b/i,
  'constant': /@[A-Z]+/,
  'time': /'[0-9:\-\s]+'/,
  'string': /"(?:[^"\\]|\\.)*"/,
  'number': /-?\d+(?:\.\d+)?%?/,
  'variable-insert': /\+[a-zA-Z][a-zA-Z0-9_]*/,
  'variable': /\b[a-zA-Z][a-zA-Z0-9_]*\b/,
  'operator': /[+|<>=!]+/,
  'wildcard': /\*/,
  'punctuation': /[[\]{}(),;]/
};

// Get DOM elements  
const scriptTextarea = document.getElementById('script');
const scriptHighlight = document.getElementById('script-highlight');

// Function to update syntax highlighting
function updateHighlight() {
  const code = scriptTextarea.value;
  const highlightedCode = Prism.highlight(code, Prism.languages.traqula, 'traqula');
  scriptHighlight.querySelector('code').innerHTML = highlightedCode;
  localStorage.setItem('bareclad-query', code);
  syncScroll();
}

// Sync scroll between textarea and highlight
function syncScroll() {
  scriptHighlight.style.top = -scriptTextarea.scrollTop + 'px';
}

// Setup event listeners for the editor
scriptTextarea.addEventListener('input', updateHighlight);
scriptTextarea.addEventListener('scroll', syncScroll);
scriptTextarea.addEventListener('keydown', function(e) {
  if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
    runQuery();
  }
  
  // Handle tab key for indentation
  if (e.key === 'Tab') {
    e.preventDefault();
    const start = this.selectionStart;
    const end = this.selectionEnd;
    const value = this.value;
    this.value = value.substring(0, start) + '    ' + value.substring(end);
    this.selectionStart = this.selectionEnd = start + 4;
    updateHighlight();
  }
});

// Initialize highlighting
setTimeout(() => {
  updateHighlight();
  setStatus('Editor loaded with syntax highlighting');
  
  // Initialize status view with welcome message
  const initTime = new Date().toLocaleTimeString();
  els.statusOut.textContent = `[${initTime}] Bareclad Query Console initialized\n[${initTime}] Editor loaded with syntax highlighting\n`;
}, 100);

// Save query on page unload
window.addEventListener('beforeunload', () => {
  localStorage.setItem('bareclad-query', scriptTextarea.value);
});

// No Monaco initialization needed - using Prism.js instead
function setStatus(msg, cls='') {
  // Update the status bar with brief messages only
  if (cls === 'err') {
    // For errors, show a brief indicator in status bar
    els.status.textContent = 'Error occurred - see Status tab for details';
    els.status.className = cls;
  } else {
    // For non-errors, show the full message
    els.status.textContent = msg;
    els.status.className = cls;
  }

  // Always log to status view with timestamp
  const timestamp = new Date().toLocaleTimeString();
  const logEntry = `[${timestamp}] ${msg}\n`;
  els.statusOut.textContent += logEntry;

  // Auto-scroll to bottom of status view
  const statusView = els.statusView;
  setTimeout(() => {
    statusView.scrollTop = statusView.scrollHeight;
  }, 0);

  // Switch to status tab if there's an error
  if (cls === 'err') {
    els.tabs.forEach(btn => btn.classList.remove('active'));
    const statusTab = document.querySelector('[data-tab="status"]');
    if (statusTab) {
      statusTab.classList.add('active');
      els.tableView.style.display = 'none';
      els.jsonView.style.display = 'none';
      els.statusView.style.display = 'block';
    }
  }
  // Switch back to table tab for successful query completion
  else if (msg === 'OK') {
    els.tabs.forEach(btn => btn.classList.remove('active'));
    const tableTab = document.querySelector('[data-tab="table"]');
    if (tableTab) {
      tableTab.classList.add('active');
      els.tableView.style.display = 'block';
      els.jsonView.style.display = 'none';
      els.statusView.style.display = 'none';
    }
  }
}
function escapeHtml(s) { return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }
function buildTable(columns, rows, rowTypes) {
  els.tableHead.innerHTML = '';
  els.tableBody.innerHTML = '';
  if (!columns || columns.length===0) return;
  // Collect unique data types for each column
  const columnTypes = columns.map((_, colIndex) => {
    const types = new Set();
    if (rowTypes) {
      rowTypes.forEach(rowType => {
        if (rowType && rowType[colIndex]) {
          types.add(rowType[colIndex]);
        }
      });
    }
    return Array.from(types).sort();
  });
  const tr = document.createElement('tr');
  columns.forEach((c,i)=>{
    const th = document.createElement('th');
    th.innerHTML = escapeHtml(c) + '<br><span>'+ escapeHtml(columnTypes[i].join(', ') || '') +'</span>';
    tr.appendChild(th);
  });
  els.tableHead.appendChild(tr);
  rows.forEach((r,ri)=>{
    const tr = document.createElement('tr');
    r.forEach((cell,ci)=>{
      const td = document.createElement('td');
      const typ = (rowTypes && rowTypes[ri] ? rowTypes[ri][ci] : '');
      let display = String(cell);
      if (typ === 'Certainty') {
        display = formatCertaintyDisplay(display);
      }
      td.innerHTML = '<span class="badge '+escapeHtml(typ)+'">'+escapeHtml(typ||'')+'</span> '+ escapeHtml(display);
      tr.appendChild(td);
    });
    els.tableBody.appendChild(tr);
    if (els.autoScroll.checked) tr.scrollIntoView({block:'end'});
  });
}

function populateResultSetSelect(resultSets) {
  const sel = els.resultSetSelect;
  if (!resultSets || resultSets.length <= 1) {
    sel.style.display = 'none';
    sel.innerHTML = '';
    return;
  }
  sel.style.display = 'inline-block';
  sel.innerHTML = '';
  resultSets.forEach((rs, idx) => {
    const opt = document.createElement('option');
    const colPreview = rs.columns.slice(0,4).join(', ');
    opt.value = idx;
    const rowCount = rs.row_count ?? (rs.rows ? rs.rows.length : undefined);
    const limited = rs.limited ? ' (limited)' : '';
    opt.textContent = rowCount !== undefined ? `Search ${idx+1} (${rowCount} rows${limited})` : `Search ${idx+1}`;
    if (rs.search) {
      const snippet = rs.search.replace(/\s+/g,' ').slice(0,120);
      opt.title = `Search ${idx+1}: ${snippet}${rs.search.length>120?'…':''}`;
      opt.dataset.snippet = rs.search; // full snippet for offset computation
    } else {
      opt.title = `Search ${idx+1} – Columns: ${colPreview}${rs.columns.length>4?'…':''}` + (rowCount!==undefined?` – ${rowCount} rows${limited}`:'');
    }
    sel.appendChild(opt);
  });
}
async function runQuery() {
  const endpoint = els.endpoint.value.trim();
  const script = scriptTextarea.value;
  const doStream = els.streamMode.checked;
  const payload = { script: script, stream: doStream };
  const timeoutMs = parseInt(els.timeout.value || '0',10);
  els.runBtn.disabled = true; setStatus('Running...'); els.progress.style.visibility='visible'; els.progress.value=15;
  const controller = timeoutMs>0 ? new AbortController() : null;
  if (controller) setTimeout(()=>controller.abort(), timeoutMs);
  const started = performance.now();
  try {
    if (doStream) {
      await runStream(endpoint, payload, started, controller);
    } else {
      const res = await fetch(endpoint, {
        method:'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify(payload),
        signal: controller? controller.signal : undefined
      });
      els.progress.value=60;
      const json = await res.json();
      lastResponse = json;
      els.progress.value=85;
      if (json.status === 'ok') {
        if (json.result_sets) {
          populateResultSetSelect(json.result_sets);
          const first = json.result_sets[0];
          buildTable(first.columns, first.rows||[], first.row_types||[]);
          els.resultSetSelect.onchange = () => {
            const idx = parseInt(els.resultSetSelect.value,10);
              const rs = json.result_sets[idx];
              buildTable(rs.columns, rs.rows||[], rs.row_types||[]);
          };
        } else {
          populateResultSetSelect(null);
          buildTable(json.columns, json.rows||[], json.row_types||[]);
        }
        const ms = (performance.now()-started).toFixed(2);
        els.perf.textContent = `client ${(ms)} ms | server ${(json.elapsed_ms).toFixed(3)} ms | rows ${json.row_count}`;
        setStatus('OK');
      } else {
        buildTable([],[],[]);
        setStatus('Error: '+ json.error, 'err');
      }
      els.jsonOut.textContent = JSON.stringify(json, null, 2);
    }
  } catch (e) {
    setStatus('Request failed: '+ e.message, 'err');
  } finally {
    els.runBtn.disabled=false; els.progress.value=100; setTimeout(()=>{els.progress.style.visibility='hidden';},400);
  }
}
async function runStream(endpoint, payload, started, controller) {
  // Reset table
  buildTable([],[],[]); populateResultSetSelect(null); els.jsonOut.textContent='';
  // Multi-search streaming accumulation structures
  let multiSets = []; // each: { columns, rows, row_types, limited }
  let currentSetIndex = 0;
  let streamingMulti = false;
  const res = await fetch(endpoint, {
    method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload), signal: controller? controller.signal:undefined
  });
  if (!res.ok) {
    const txt = await res.text();
    setStatus('Stream init error: HTTP '+res.status, 'err');
    els.jsonOut.textContent = txt; return;
  }
  const reader = res.body.getReader();
  const decoder = new TextDecoder();
  let buffer = '';
  let columns = null; let rowTypesAll = []; let rowCount=0; let limited=false;
  const rows = [];
  function flushEvents(text) {
    const parts = text.split(/\n\n/);
    for (let part of parts) {
      if (!part.trim()) continue;
      const line = part.trim();
      if (!line.startsWith('data:')) continue;
      const jsonStr = line.slice(5).trim();
      try {
        const evt = JSON.parse(jsonStr);
        if (evt.event==='meta') {
          columns = evt.columns; limited = !!evt.limited; setStatus('Streaming meta received');
          buildTable(columns, [], []);
        } else if (evt.event==='result_set_start') {
            // Start of new result set
            streamingMulti = true;
            if (!evt.columns) continue;
            multiSets.push({ columns: evt.columns, rows: [], row_types: [], limited: false, search: evt.search || null });
            const idx = evt.index;
            // If first set, initialize overall view
            if (multiSets.length === 1) {
              currentSetIndex = 0;
              buildTable(evt.columns, [], []);
            }
            // Show dropdown once we have >1 set
            if (multiSets.length > 1) {
              const sel = els.resultSetSelect;
              sel.style.display='inline-block';
              // Rebuild options
              sel.innerHTML='';
              multiSets.forEach((s,i)=>{ const opt=document.createElement('option'); const rc = s.row_count || s.rows.length || 0; const limited = s.limited ? ' (limited)' : ''; opt.value=i; opt.textContent=`Search ${i+1} (${rc} rows${limited})`; if (s.search) { const snippet = s.search.replace(/\s+/g,' ').slice(0,120); opt.title=`Search ${i+1}: ${snippet}${s.search.length>120?'…':''}`; opt.dataset.snippet = s.search; } else { opt.title=`Search ${i+1}`;} sel.appendChild(opt); });
              // Preserve previously selected if still valid
              sel.value = String(currentSetIndex);
              sel.onchange = () => { currentSetIndex = parseInt(sel.value,10); const s = multiSets[currentSetIndex]; buildTable(s.columns, s.rows, s.row_types); };
              computeSearchOffsetsForOptions();
            }
            setStatus(`Result set ${idx+1} start`);
        } else if (evt.event==='row') {
            if (streamingMulti && typeof evt.index === 'number' && multiSets[evt.index]) {
              const set = multiSets[evt.index];
              set.rows.push(evt.row); set.row_types.push(evt.types); set.row_count = set.rows.length;
              if (evt.index === currentSetIndex) {
                buildTable(set.columns, set.rows, set.row_types);
              }
              // Refresh dropdown option text to reflect new row counts
              if (multiSets.length > 1) {
                const sel = els.resultSetSelect;
                const prevSelection = sel.value;
                Array.from(sel.options).forEach((optEl, i)=>{
                  const s = multiSets[i]; const rc = s.row_count || s.rows.length || 0; const limitedTxt = s.limited ? ' (limited)' : ''; optEl.textContent = `Search ${i+1} (${rc} rows${limitedTxt})`; if (s.search) { const snippet = s.search.replace(/\s+/g,' ').slice(0,120); optEl.title=`Search ${i+1}: ${snippet}${s.search.length>120?'…':''}`; }
                });
                sel.value = prevSelection;
              }
              els.perf.textContent = `stream sets ${multiSets.length} | rows set${evt.index+1}=${set.rows.length}`;
            } else { // single-search path
              rows.push(evt.row); rowTypesAll.push(evt.types); rowCount = rows.length;
              buildTable(columns, rows, rowTypesAll);
              els.perf.textContent = `stream rows ${rowCount}`;
            }
        } else if (evt.event==='result_set_end') {
            if (streamingMulti && typeof evt.index === 'number' && multiSets[evt.index]) {
              multiSets[evt.index].limited = evt.limited;
              multiSets[evt.index].row_count = evt.row_count;
              setStatus(`Result set ${evt.index+1} end (${evt.row_count} rows${evt.limited?' limited':''})`);
              // Final refresh for this result set to include limited flag
              if (multiSets.length > 1) {
                const sel = els.resultSetSelect; const prevSelection = sel.value;
                Array.from(sel.options).forEach((optEl, i)=>{ const s=multiSets[i]; const rc=s.row_count||s.rows.length||0; const limitedTxt = s.limited ? ' (limited)' : ''; optEl.textContent=`Search ${i+1} (${rc} rows${limitedTxt})`; if (s.search) { const snippet = s.search.replace(/\s+/g,' ').slice(0,120); optEl.title=`Search ${i+1}: ${snippet}${s.search.length>120?'…':''}`; } });
                sel.value = prevSelection;
              }
            }
    } else if (evt.event==='multi_end') {
            const ms = (performance.now()-started).toFixed(2);
            if (streamingMulti) {
              const total = evt.total_rows ?? multiSets.reduce((a,s)=>a+(s.row_count||s.rows.length),0);
              els.perf.textContent = `client ${(ms)} ms | sets ${multiSets.length} | total rows ${total}`;
              setStatus('OK');
              els.jsonOut.textContent = JSON.stringify({ status:'ok', result_sets: multiSets.map((s,i)=>({ index:i, columns:s.columns, rows:s.rows, row_types:s.row_types, row_count: s.row_count||s.rows.length, limited: !!s.limited, search: s.search })) }, null, 2);
            } else {
              els.perf.textContent = `client ${(ms)} ms | total rows ${evt.total_rows ?? rowCount}`;
              setStatus('OK');
              const summary = { status:'ok', last_set: { columns, rows, row_types: rowTypesAll, row_count: rowCount }, total_rows: evt.total_rows ?? rowCount };
              els.jsonOut.textContent = JSON.stringify(summary,null,2);
            }
        } else if (evt.event==='error') {
            setStatus('Stream error: '+evt.error, 'err');
        } else if (evt.event==='end') {
      // Fallback completion (single-search or legacy); if multi already handled do nothing extra
            const ms = (performance.now()-started).toFixed(2);
            els.perf.textContent = `client ${(ms)} ms | rows ${rowCount}${limited?' (limited)':''}`;
            setStatus('OK');
            // Summarize JSON output
            const summary = { status:'ok', columns, rows, row_types: rowTypesAll, row_count: rowCount, limited };
            els.jsonOut.textContent = JSON.stringify(summary,null,2);
        }
      } catch (e) { /* ignore parse errors mid-stream */ }
    }
  }
  while (true) {
    const {done, value} = await reader.read();
    if (done) break;
    buffer += decoder.decode(value, {stream:true});
    // Attempt to flush complete events
    const lastSep = buffer.lastIndexOf('\n\n');
    if (lastSep !== -1) {
      const toFlush = buffer.slice(0,lastSep+2); // include sep
      flushEvents(toFlush);
      buffer = buffer.slice(lastSep+2);
    }
  }
  flushEvents(buffer); // flush remainder
}
els.runBtn.addEventListener('click', runQuery);
els.clearBtn.addEventListener('click', ()=>{ 
  els.tableHead.innerHTML=''; 
  els.tableBody.innerHTML=''; 
  els.jsonOut.textContent=''; 
  els.statusOut.textContent=''; 
  els.perf.textContent=''; 
  // Hide and reset result set selector so old streaming sets cannot be resurrected
  els.resultSetSelect.style.display='none';
  els.resultSetSelect.innerHTML='';
  els.resultSetSelect.onchange = null;
  lastResponse = null;
  setStatus('Cleared'); 
});

// Tabs switching
els.tabs.forEach(btn=>{
  btn.addEventListener('click', ()=>{
    els.tabs.forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    const tab = btn.getAttribute('data-tab');
    if (tab==='table') { 
      els.tableView.style.display='block'; 
      els.jsonView.style.display='none'; 
      els.statusView.style.display='none'; 
    }
    else if (tab==='json') { 
      els.tableView.style.display='none'; 
      els.jsonView.style.display='block'; 
      els.statusView.style.display='none'; 
    }
    else if (tab==='status') { 
      els.tableView.style.display='none'; 
      els.jsonView.style.display='none'; 
      els.statusView.style.display='block'; 
    }
  });
});

// Vertical splitter drag logic
let dragging = false; let startY = 0; let startHeight = 0;
function setEditorHeight(px){
  const min = 100; const max = window.innerHeight * 0.85;
  const clamped = Math.min(Math.max(px,min), max);
  els.editorPane.style.flex = '0 0 '+clamped+'px';
}
els.splitter.addEventListener('mousedown', e=>{
  dragging = true; startY = e.clientY; startHeight = els.editorPane.getBoundingClientRect().height;
  document.body.style.cursor='row-resize';
  e.preventDefault();
});
window.addEventListener('mousemove', e=>{
  if (!dragging) return; const dy = e.clientY - startY; setEditorHeight(startHeight + dy);
});
window.addEventListener('mouseup', ()=>{ if (dragging) { dragging=false; document.body.style.cursor=''; }});
window.addEventListener('resize', ()=>{ /* keep within bounds */ setEditorHeight(els.editorPane.getBoundingClientRect().height); });

function formatCertaintyDisplay(raw) {
  if (raw === undefined || raw === null) return raw;
  if (raw === '?') return raw;
  // Expect forms: -1, -0.xx, 0, 0.xx, 1
  if (raw === '1' || raw === '-1') return (raw.startsWith('-')?'-':'') + '100%';
  if (raw === '0') return '0%';
  const m = raw.match(/^(-?)0\.(\d{1,2})$/);
  if (m) {
    const sign = m[1];
    const digits = m[2];
    // strip potential leading zero in percent, keep as integer ("05" -> 5) but preserve up to 2 digits
    const pct = parseInt(digits,10); // safe
    return sign + pct + '%';
  }
  return raw; // fallback
}
</script>
</body>
</html>
